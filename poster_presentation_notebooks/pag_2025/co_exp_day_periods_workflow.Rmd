---
title: "Co-expression network analysis"
output: html_notebook
---

Following the [SimpleTidy GeneCoEx workflow](https://github.com/cxli233/SimpleTidy_GeneCoEx) created by Dr. Chenxin Li for the analysis of co-expression networks.

# Importing TPM gene expression matrices and initial data exploration

Importing the necessary libraries for the analysis:

```{r}
library(tidyverse)
library(igraph)
library(ggraph)
library(readxl)
library(patchwork)
library(RColorBrewer)
library(viridis)
```

Importing the TPM gene expression matrices.

`Exp_table` was generated by running Salmon on the RNA-seq data from Kremling et al. (2018) and using the index of Maize v5 as the reference transcriptome. The genes were filtered by low expression (RPKM) and coefficient of variation (CV) values. A second matrix, `Full_Expr_table`, was generated using the same pipeline, but without filtering the genes by low expression or CV values.

```{r}
Full_Expr_table <- read_tsv("/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/plant_center_retreat_2024/kremling_expression_v5_tpm.tsv", col_types = cols())
Exp_table <- read_tsv("/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/plant_center_retreat_2024/kremling_expression_v5_tpm_filtered_cv_filtered.tsv", col_types = cols())
head(Full_Expr_table)
dim(Full_Expr_table)
head(Exp_table)
dim(Exp_table)
```

Generating the Tidy data frame for the gene expression matrix:

```{r}
Full_Expr_table_long <- Full_Expr_table %>% 
  pivot_longer(cols = !Name, names_to = "SampleName", values_to = "TPM") %>% 
  mutate(logTPM = log10(TPM + 1))

head(Full_Expr_table_long)

Exp_table_long <- Exp_table %>% 
  pivot_longer(cols = !Name, names_to = "SampleName", values_to = "TPM") %>% 
  mutate(logTPM = log10(TPM + 1))

head(Exp_table_long)
```

Generating a wide version again (with log TPM values):

```{r}
Exp_table_log_wide <- Exp_table_long %>% 
  select(Name, SampleName, logTPM) %>% 
  pivot_wider(names_from = SampleName, values_from = logTPM)

head(Exp_table_log_wide)

Full_Expr_table_long_wide <- Full_Expr_table_long %>% 
  select(Name, SampleName, logTPM) %>% 
  pivot_wider(names_from = SampleName, values_from = logTPM)

head(Full_Expr_table_long_wide)
```

Importing metadata:

```{r}
sample_metadata <- read_tsv("/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/sample_annotation.txt",
                            show_col_types = FALSE)
head(sample_metadata)
```

Generating a PCA:

```{r}
my_pca <- prcomp(t(Exp_table_log_wide[, -1]))
pca_importance <- as.data.frame(t(summary(my_pca)$importance))
head(pca_importance, 20)

my_pca_full <- prcomp(t(Full_Expr_table_long_wide[, -1]))
pca_importance_full <- as.data.frame(t(summary(my_pca_full)$importance))
head(pca_importance_full, 20)
```

```{r}
head(as.data.frame(my_pca$x[, 1:10]))
```

Adding metadata to the PCA matrix:

```{r}
PCA_coord_full <- my_pca_full$x[, 1:10] %>% 
  as.data.frame() %>% 
  mutate(SampleName = row.names(.)) %>% 
  full_join(sample_metadata %>% 
              select(Genotype, Subpopulation, DayPeriod, Tissue, SampleName), by = "SampleName")

head(PCA_coord_full)

PCA_coord <- my_pca$x[, 1:10] %>% 
  as.data.frame() %>% 
  mutate(SampleName = row.names(.)) %>% 
  full_join(sample_metadata %>% 
              select(Genotype, Subpopulation, DayPeriod, Tissue, SampleName), by = "SampleName")

head(PCA_coord)
```

Plotting the PCA with the Full RNA-Seq matrix (log transformed TPM values):

```{r}
PCA_by_day_period_full <- PCA_coord_full %>% 
  ggplot(aes(x = PC1, y = PC2)) +
  geom_point(aes(fill = DayPeriod), color = "grey20", shape = 21, size = 3, alpha = 0.8) +
  scale_fill_manual(values = brewer.pal(n = 3, "Accent")) +
  labs(x = paste("PC1 (", pca_importance_full[1, 2] %>% signif(3)*100, "% of Variance)", sep = ""), 
       y = paste("PC2 (", pca_importance_full[2, 2] %>% signif(3)*100, "% of Variance)", "  ", sep = ""),
       fill = NULL) +  
  theme_bw() +
  theme(
    text = element_text(size= 14),
    axis.text = element_text(color = "black")
  )

PCA_by_day_period_full
```

Plotting the PCA with the RNA-Seq matrix (log transformed TPM values) for the subset used in cross-correlations (gene vs. OTU):

```{r}
PCA_by_day_period <- PCA_coord %>% 
  ggplot(aes(x = PC1, y = PC2)) +
  geom_point(aes(fill = DayPeriod), color = "grey20", shape = 21, size = 3, alpha = 0.8) +
  scale_fill_manual(values = brewer.pal(n = 3, "Accent")) +
  labs(x = paste("PC1 (", pca_importance[1, 2] %>% signif(3)*100, "% of Variance)", sep = ""), 
       y = paste("PC2 (", pca_importance[2, 2] %>% signif(3)*100, "% of Variance)", "  ", sep = ""),
       fill = NULL) +  
  theme_bw() +
  theme(
    text = element_text(size= 14),
    axis.text = element_text(color = "black")
  )

PCA_by_day_period
```

```{r}
PCA_by_subpopulation <- PCA_coord %>% 
  ggplot(aes(x = PC1, y = PC2)) +
  geom_point(aes(fill = Subpopulation), color = "grey20", shape = 21, size = 3, alpha = 0.8) +
  labs(x = paste("PC1 (", pca_importance[1, 2] %>% signif(3)*100, "% of Variance)", sep = ""), 
       y = paste("PC2 (", pca_importance[2, 2] %>% signif(3)*100, "% of Variance)", "  ", sep = ""),
       fill = NULL) +  
  theme_bw() +
  theme(
    text = element_text(size= 14),
    axis.text = element_text(color = "black")
  )

PCA_by_subpopulation
```

# Importing the correlation matrices.

I (RACS) generated two different networks in corALS:

 * Day
 * Night
 
Later, a single network will also be generated, including both conditions.

Importing the two (day, night) networks:

```{r}
day_cor_matrix <- as.data.frame(read_tsv("/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/co_exp_day_pearson_correlation.tsv", col_types = cols()))
rownames(day_cor_matrix) <- day_cor_matrix[, 1]
day_cor_matrix <- day_cor_matrix[, -1]
head(day_cor_matrix)
night_cor_matrix <- as.data.frame(read_tsv("/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/co_exp_night_pearson_correlation.tsv", col_types = cols()))
rownames(night_cor_matrix) <- night_cor_matrix[, 1]
night_cor_matrix <- night_cor_matrix[, -1]
head(night_cor_matrix)
all_cor_matrix <- as.data.frame(read_tsv("/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/co_exp_pearson_correlation.tsv", col_types = cols()))
rownames(all_cor_matrix) <- all_cor_matrix[, 1]
all_cor_matrix <- all_cor_matrix[, -1]
head(all_cor_matrix)
```

We don't really need duplicated information contained in the lower triangle of the matrix, so we can set it to NA:

```{r}
day_cor_matrix_tri <- day_cor_matrix
day_cor_matrix_tri[lower.tri(day_cor_matrix_tri)] <- NA
head(day_cor_matrix_tri, n=2)
night_cor_matrix_tri <- night_cor_matrix
night_cor_matrix_tri[lower.tri(night_cor_matrix_tri)] <- NA
head(night_cor_matrix_tri)
all_cor_matrix_tri <- all_cor_matrix
all_cor_matrix_tri[lower.tri(all_cor_matrix_tri)] <- NA
head(all_cor_matrix_tri)
```

For a initial edge selection, I (RACS) will use a correlation threshold of 0.5 (p-values and corrected p-values generated by corALS, so I will probably look at these values later):

```{r}

# Converting the adjacency matrix to an edge table
all_edge_table <- all_cor_matrix_tri %>% 
  as.data.frame() %>% 
  mutate(from = row.names(all_cor_matrix)) %>%
  pivot_longer(cols = !from, names_to = "to", values_to = "r") %>%
  filter(is.na(r) == F) %>%
  filter(from != to)

head(all_edge_table)
dim(all_edge_table)

# Filtering edges with correlation coefficient >= 0.5
all_edge_table_select <- all_edge_table %>% 
  filter(r >= 0.5)

head(all_edge_table_select)
dim(all_edge_table_select)

# Converting the adjacency matrix to an edge table
day_edge_table <- day_cor_matrix_tri %>% 
  as.data.frame() %>% 
  mutate(from = row.names(day_cor_matrix)) %>%
  pivot_longer(cols = !from, names_to = "to", values_to = "r") %>%
  filter(is.na(r) == F) %>%
  filter(from != to)

head(day_edge_table)
dim(day_edge_table)

# Filtering edges with correlation coefficient >= 0.5
day_edge_table_select <- day_edge_table %>% 
  filter(r >= 0.5)

head(day_edge_table_select)
dim(day_edge_table_select)

# Converting the adjacency matrix to an edge table
night_edge_table <- night_cor_matrix_tri %>% 
  as.data.frame() %>% 
  mutate(from = row.names(night_cor_matrix)) %>%
  pivot_longer(cols = !from, names_to = "to", values_to = "r") %>%
  filter(is.na(r) == F) %>%
  filter(from != to)

head(night_edge_table)
dim(night_edge_table)

# Filtering edges with correlation coefficient >= 0.5
night_edge_table_select <- night_edge_table %>% 
  filter(r >= 0.5)

head(night_edge_table_select)
dim(night_edge_table_select)
```

Creating node list with maize functional annotation, when available:

```{r}
maize_funct_anno <- read_delim("/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/plant_center_retreat_2024/kremling_expression_v5_tpm_filtered_cv_filtered_annotations.txt", delim = "\t", col_names = F, col_types = cols())
head(maize_funct_anno)

day_node_table <- data.frame(
  Name = c(day_edge_table_select$from, day_edge_table_select$to) %>% unique()
) %>% 
  left_join(maize_funct_anno, by = c("Name"="X1")) %>% 
  rename(functional_annotation = X2)
head(day_node_table)
dim(day_node_table)

night_node_table <- data.frame(
  Name = c(night_edge_table_select$from, night_edge_table_select$to) %>% unique()
) %>% 
  left_join(maize_funct_anno, by = c("Name"="X1")) %>% 
  rename(functional_annotation = X2)
head(night_node_table)
dim(night_node_table)

all_node_table <- data.frame(
  Name = c(all_edge_table_select$from, all_edge_table_select$to) %>% unique()
) %>% 
  left_join(maize_funct_anno, by = c("Name"="X1")) %>% 
  rename(functional_annotation = X2)
head(all_node_table)
dim(all_node_table)
```

Creating the networks:

```{r}
all_network <- graph_from_data_frame(
  all_edge_table_select,
  vertices = all_node_table,
  directed = F
)

day_network <- graph_from_data_frame(
  day_edge_table_select,
  vertices = day_node_table,
  directed = F
)

night_network <- graph_from_data_frame(
  night_edge_table_select,
  vertices = night_node_table,
  directed = F
)
```

Clustering the networks. Chinxen Li's function for optimizing the selection of resolution parameter when clustering the networks:

```{r}
optimize_resolution <- function(network, resolution){
  modules = network %>% 
    cluster_leiden(resolution_parameter = resolution,
                   objective_function = "modularity")
  
  parsed_modules = data.frame(
    Name = names(membership(modules)),
    module = as.vector(membership(modules)) 
    )
  
  num_module_5 = parsed_modules %>% 
    group_by(module) %>% 
    count() %>% 
    arrange(-n) %>% 
    filter(n >= 5) %>% 
    nrow() %>% 
    as.numeric()
  
  num_genes_contained = parsed_modules %>% 
    group_by(module) %>% 
    count() %>% 
    arrange(-n) %>% 
    filter(n >= 5) %>% 
    ungroup() %>% 
    summarise(sum = sum(n)) %>% 
    as.numeric()
  
  c(num_module_5, num_genes_contained)

}
```

Running the function for the day and night networks, and the network wii all samples combined:

```{r}
optimization_results_all <- purrr::map_dfc(
  .x = seq(from = 0.25, to = 20, by = 0.25),
  .f = optimize_resolution, 
  network = all_network
) %>% 
  t() %>% 
  cbind(
   resolution = seq(from = 0.25, to = 20, by = 0.25)
  ) %>% 
  as.data.frame() %>% 
  rename(num_module = V1,
         num_contained_gene = V2)

optimization_results_day <- purrr::map_dfc(
  .x = seq(from = 0.25, to = 10, by = 0.25),
  .f = optimize_resolution, 
  network = day_network
) %>% 
  t() %>% 
  cbind(
   resolution = seq(from = 0.25, to = 10, by = 0.25)
  ) %>% 
  as.data.frame() %>% 
  rename(num_module = V1,
         num_contained_gene = V2)

optimization_results_night <- purrr::map_dfc(
  .x = seq(from = 0.25, to = 10, by = 0.25),
  .f = optimize_resolution, 
  network = night_network
) %>% 
  t() %>% 
  cbind(
   resolution = seq(from = 0.25, to = 10, by = 0.25)
  ) %>% 
  as.data.frame() %>% 
  rename(num_module = V1,
         num_contained_gene = V2)
```

Plotting:

```{r}
Optimize_num_module_all <- optimization_results_all %>% 
  ggplot(aes(x = resolution, y = num_module)) +
  geom_line(size = 1.1, alpha = 0.8, color = "dodgerblue2") +
  geom_point(size = 3, alpha = 0.7) +
  geom_vline(xintercept = 10.25, size = 1, linetype = 4) +
  labs(x = "resolution parameter",
       y = "num. modules\nw/ >=5 genes") +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.text = element_text(color = "black")
  )

Optimize_num_gene_all <- optimization_results_all %>% 
  ggplot(aes(x = resolution, y = num_contained_gene)) +
  geom_line(size = 1.1, alpha = 0.8, color = "violetred2") +
  geom_point(size = 3, alpha = 0.7) +
  geom_vline(xintercept = 10.25, size = 1, linetype = 4) +
  labs(x = "resolution parameter",
       y = "num. genes in\nmodules w/ >=5 genes") +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.text = element_text(color = "black")
  )

wrap_plots(Optimize_num_module_all, Optimize_num_gene_all, nrow = 2)
```

```{r}
Optimize_num_module_day <- optimization_results_day %>% 
  ggplot(aes(x = resolution, y = num_module)) +
  geom_line(size = 1.1, alpha = 0.8, color = "dodgerblue2") +
  geom_point(size = 3, alpha = 0.7) +
  geom_vline(xintercept = 6.25, size = 1, linetype = 4) +
  labs(x = "resolution parameter",
       y = "num. modules\nw/ >=5 genes") +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.text = element_text(color = "black")
  )

Optimize_num_gene_day <- optimization_results_day %>% 
  ggplot(aes(x = resolution, y = num_contained_gene)) +
  geom_line(size = 1.1, alpha = 0.8, color = "violetred2") +
  geom_point(size = 3, alpha = 0.7) +
  geom_vline(xintercept = 6.25, size = 1, linetype = 4) +
  labs(x = "resolution parameter",
       y = "num. genes in\nmodules w/ >=5 genes") +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.text = element_text(color = "black")
  )

wrap_plots(Optimize_num_module_day, Optimize_num_gene_day, nrow = 2)
```

```{r}
Optimize_num_module_night <- optimization_results_night %>% 
  ggplot(aes(x = resolution, y = num_module)) +
  geom_line(size = 1.1, alpha = 0.8, color = "dodgerblue2") +
  geom_point(size = 3, alpha = 0.7) +
  geom_vline(xintercept = 5.75, size = 1, linetype = 4) +
  labs(x = "resolution parameter",
       y = "num. modules\nw/ >=5 genes") +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.text = element_text(color = "black")
  )

Optimize_num_gene_night <- optimization_results_night %>% 
  ggplot(aes(x = resolution, y = num_contained_gene)) +
  geom_line(size = 1.1, alpha = 0.8, color = "violetred2") +
  geom_point(size = 3, alpha = 0.7) +
  geom_vline(xintercept = 5.75, size = 1, linetype = 4) +
  labs(x = "resolution parameter",
       y = "num. genes in\nmodules w/ >=5 genes") +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.text = element_text(color = "black")
  )

wrap_plots(Optimize_num_module_night, Optimize_num_gene_night, nrow = 2)
```


```{r}
all_net_modules <- cluster_leiden(all_network, resolution_parameter = 10.25,
                          objective_function = "modularity")
day_net_modules <- cluster_leiden(day_network, resolution_parameter = 6.25,
                          objective_function = "modularity")
night_net_modules <- cluster_leiden(night_network, resolution_parameter = 5.75, 
                          objective_function = "modularity")
length(day_net_modules)
length(night_net_modules)
length(all_net_modules)
```

Obtaining some statistics about the modules:

```{r}
network_modules_all <- data.frame(
  Name = names(membership(all_net_modules)),
  module = as.vector(membership(all_net_modules)) 
) %>% 
  inner_join(all_node_table, by = "Name")

# Getting the number of modules with more than 5 genes in them
network_modules_all %>% 
  group_by(module) %>% 
  count() %>% 
  arrange(-n) %>% 
  filter(n >= 5)

# Getting the number of genes in such modules (> 5 genes)
network_modules_all %>% 
  group_by(module) %>% 
  count() %>% 
  arrange(-n) %>% 
  filter(n >= 5) %>% 
  ungroup() %>% 
  summarise(sum = sum(n))

network_modules_day <- data.frame(
  Name = names(membership(day_net_modules)),
  module = as.vector(membership(day_net_modules)) 
) %>% 
  inner_join(day_node_table, by = "Name")

# Getting the number of modules with more than 5 genes in them
network_modules_day %>% 
  group_by(module) %>% 
  count() %>% 
  arrange(-n) %>% 
  filter(n >= 5)

# Getting the number of genes in such modules (> 5 genes)
network_modules_day %>% 
  group_by(module) %>% 
  count() %>% 
  arrange(-n) %>% 
  filter(n >= 5) %>% 
  ungroup() %>% 
  summarise(sum = sum(n))

head(network_modules_day, n=40)

network_modules_night <- data.frame(
  Name = names(membership(night_net_modules)),
  module = as.vector(membership(night_net_modules)) 
) %>% 
  inner_join(night_node_table, by = "Name")

# Getting the number of modules with more than 5 genes in them
network_modules_night %>% 
  group_by(module) %>% 
  count() %>% 
  arrange(-n) %>% 
  filter(n >= 5)

# Getting the number of genes in such modules (> 5 genes)
network_modules_night %>% 
  group_by(module) %>% 
  count() %>% 
  arrange(-n) %>% 
  filter(n >= 5) %>% 
  ungroup() %>% 
  summarise(sum = sum(n))

head(network_modules_night, n=40)
```



```{r}
# Getting the number of modules with more than 5 genes in them
modules_all_gt5genes <- network_modules_all %>% 
  group_by(module) %>% 
  count() %>% 
  arrange(-n) %>% 
  filter(n >= 5)

head(modules_all_gt5genes)

# Getting the genes in such modules (> 5 genes)
network_modules_all_gt5genes <- network_modules_all %>% 
  filter(module %in% modules_all_gt5genes$module)

# Computing the z-scores for the wide table with the ~7000 genes (filtered and used in co-expression analysis)
head(Exp_table_long)
Exp_table_long_z <- Exp_table_long %>% 
  group_by(Name) %>% 
  mutate(z.score = (logTPM - mean(logTPM))/sd(logTPM)) %>% 
  ungroup()
head(Exp_table_long_z)
dim(Exp_table_long_z)

# Adding module information to the Exp_table_long_z dataframe and keeping only records with module information
Exp_table_long_z <- Exp_table_long_z %>% 
  inner_join(network_modules_all_gt5genes %>% select(Name, module), by = "Name")
dim(Exp_table_long_z)
# Adding day period information to the Exp_table_long_z dataframe
Exp_table_long_z <- Exp_table_long_z %>% 
  inner_join(sample_metadata %>% select(SampleName, DayPeriod), by = "SampleName")
dim(Exp_table_long_z)
# Ensure SampleName is a factor with correct order
Exp_table_long_z <- Exp_table_long_z %>%
  mutate(SampleName = factor(SampleName, levels = unique(Exp_table_long_z$SampleName)))
dim(Exp_table_long_z)
head(Exp_table_long_z)

write.table(Exp_table_long_z, file = "Exp_table_long_z.txt", sep = "\t", quote = F, row.names = F)

# Getting details about the t.test function
?t.test
?p.adjust

# Test differences between day and night periods for each module
modules_t_test <- Exp_table_long_z %>% 
  group_by(module) %>% 
  summarise(
    p.value = t.test(TPM ~ DayPeriod)$p.value,
    mean_day = mean(TPM[DayPeriod == "day"]),
    mean_night = mean(TPM[DayPeriod == "night"]),
    log_fold_change = log2(mean_day/mean_night)
  ) %>% 
  mutate(adj_p.value = p.adjust(p.value, method = "bonferroni")) %>%
  filter(adj_p.value < 0.05) %>%
  filter(abs(log_fold_change) > 1) %>%
  arrange(desc(abs(log_fold_change)))

write.table(modules_t_test, file = "modules_t_test.txt", sep = "\t", quote = F, row.names = F)

# Plotting z-scores for each module
p <- ggplot(Exp_table_long_z, aes(x = SampleName, y = z.score)) +
  facet_wrap(~module, scales = "free_x") +  # Facet by module
  geom_line(aes(group = Name), alpha = 0.3, color = "grey70") +
  labs(
    x = NULL,
    y = "z-score"
  ) +
  theme_classic() +
  theme(
    text = element_text(size = 6),
    axis.text.x = element_blank(),
    panel.spacing = unit(1, "line")
  )

ggsave("plot.pdf", plot = p, width = 20, height = 10)
ggsave("plot.png", plot = p, width = 20, height = 10)

# Create a named vector of colors based on DayPeriod
# This vector will be the same for any module
sample_colors <- Exp_table_long_z %>%
  filter(module == 64) %>%
  distinct(SampleName, DayPeriod) %>%
  mutate(color = ifelse(DayPeriod == "day", "gold", "blue")) %>%  # Map "Day" to gold and "Night" to blue
  select(SampleName, color) %>%  # Keep only SampleName and color columns
  deframe()

# Plot z-scores for each gene in module 118
p_single_module <- Exp_table_long_z %>% 
  filter(module == 118) %>% 
  ggplot(aes(x = SampleName, y = z.score)) +
  geom_line(aes(group = Name), alpha = 0.3, color = "grey70") +
  stat_summary(fun = mean, aes(group = 1), geom = "line", color = "black", size = 1.2) +
  labs(
    x = NULL,
    y = "z-score",
    title = "Module 118"
  ) +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.text.x = element_text(
      size = 4,
      angle = 90,
      hjust = 1,
      color = sample_colors[levels(factor(Exp_table_long_z$SampleName))]
    ),
    axis.ticks.x = element_blank(),
    panel.spacing = unit(1, "line")
  )

ggsave("plot2_mod118_means.pdf", plot = p_single_module, width = 20, height = 10)
ggsave("plot2_mod118_means.png", plot = p_single_module, width = 20, height = 10)
```

For selection of the bait genes, we are probably going to use circadian genes with clear expression peaks around noon or midnight, since we are comparing day and night periods and only have two time points (11AM-1PM and 11PM-1AM).


```{r}
deg_clock_genes <- c('Zm00001eb072870_T003', # up (night)
                     'Zm00001eb428070_T001', # up (night)
                     'Zm00001eb397240_T001', # down (night) # GRMZM2G095727
                     'Zm00001eb159890_T001' # down (night)
                 )

subset(Exp_table, Name %in% deg_clock_genes)
subset(network_modules_day, Name %in% deg_clock_genes)
subset(network_modules_night, Name %in% deg_clock_genes)
subset(network_modules_all, Name %in% deg_clock_genes)
```

Major factors in the experiment:

```{r}
#Counting samples of different maize subpopulations
sample_metadata %>% 
  group_by(Subpopulation) %>% 
  count()
```

```{r}
#Counting samples of different day periods
sample_metadata %>% 
  group_by(DayPeriod) %>% 
  count()
```


# Network generation for Wallace et al. 2018

I (RACS) will use different datasets for the OTU counts:

 * Merged day and night (used in cross-correlation analyses, selecting samples with RNA-Seq pairs)
 * The original dataset with all samples (day and night samples considered separately)

To reduce the number of OTUs used in the analyses, I (RACS) will use the same OTUs used in the SparXCC analyses (cross-correlations between genes and OTUs) for some analyses:

 * `summed_day_night_otu_counts_filtered_sparxcc_data.tsv` is the table with OTU counts, but after selecting only the OTUs used in the SparXCC analyses.
 * `original_otu_counts_filtered_sparxcc_data.tsv` is the original OTU table counts (with all samples, not only the paired), after selecting only the OTUs used in the SparXCC analyses.

`summed_day_night_otu_counts_filtered_sparxcc_data.tsv` is different from the matrix used in SparXCC, because that way preserved the 'day' and 'night' labels in matrix columns just for the purpose of matching names in the RNA-seq (but they had the same values).
Since we are now interested ONLY in the relations among the OTU nodes (co-occurrence networks), we will keep the names referring only to plot and day (e.g., 14A0199_8).

Additionally, I (RACS) will also use the original OTU table counts (with all samples, not only the paired), to compare networks between day and night samples:
 * `original_otu_filtered_day.tsv`
 * `original_otu_filtered_night.tsv`

These datasets were obtained as described in `co_occurrence_matrix_day_periods.ipynb` (PAG 25 folder).

## Testing if networks for day and night samples are similar

To test if if networks for day and night samples are similar, I (RACS) used SpiecEasi with MB model to reconstruct separate networks for the day and the night matrices from the original OTU table after filtering by relative abundance (keeping OTUs with 0.001 relative abundance for at least half samples, approx. 270 samples). Filtering steps are described in `co_occurrence_matrix_day_periods.ipynb`.

Running spiec.easi with the day and night datasets:

```{r}
library(SpiecEasi)
otu_day_filtered_wallace2018 <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/original_otu_filtered_day.tsv', sep='\t', header=TRUE, row.names=1)
otu_night_filtered_wallace2018 <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/original_otu_filtered_night.tsv', sep='\t', header=TRUE, row.names=1)
head(otu_day_filtered_wallace2018)
head(otu_night_filtered_wallace2018)
# Transposing the matrices
otu_day_filtered_wallace2018_transposed <- t(otu_day_filtered_wallace2018)
otu_night_filtered_wallace2018_transposed <- t(otu_night_filtered_wallace2018)
# Using Meinshausen-Bühlman (MB) method (node wise regression model)
se.mb.day_filtered_wallace2018 <- spiec.easi(otu_day_filtered_wallace2018_transposed, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=1))
se.mb.night_filtered_wallace2018 <- spiec.easi(otu_night_filtered_wallace2018_transposed, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=1))
```

Visualizing the network with igraph:

```{r}
# Adding OTU names to the adjacency matrix
se.mb.night_filtered_wallace2018_matrix <- getRefit(se.mb.night_filtered_wallace2018)
se.mb.day_filtered_wallace2018_matrix <- getRefit(se.mb.day_filtered_wallace2018)
rownames(se.mb.day_filtered_wallace2018_matrix) <- colnames(otu_day_filtered_wallace2018_transposed)
rownames(se.mb.night_filtered_wallace2018_matrix) <- colnames(otu_night_filtered_wallace2018_transposed)

ig.day.mb <- adj2igraph(se.mb.day_filtered_wallace2018_matrix, vertex.attr=list(name=rownames(se.mb.day_filtered_wallace2018_matrix)))
ig.night.mb <- adj2igraph(se.mb.night_filtered_wallace2018_matrix, vertex.attr=list(name=rownames(se.mb.night_filtered_wallace2018_matrix)))

## set size of vertex proportional to clr-mean (from [spiec-easi tutorial](https://github.com/zdk123/SpiecEasi))
vsize.night    <- rowMeans(clr(otu_night_filtered_wallace2018_transposed, 1))+6
vsize.day    <- rowMeans(clr(otu_day_filtered_wallace2018_transposed, 1))+6

```

Using Fruchterman-Reingold layout (a force-directed layout) for node placement.
Strongly connected nodes are close together; nodes with low edge weight are far apart.
See [Lahti et al. 2021. Orchestrating Microbiome Analysis with Bioconductor](https://microbiome.github.io/OMA/docs/devel/pages/60_network_learning.html)
See also [this link from sciencedirect](https://www.sciencedirect.com/topics/computer-science/reingold-layout)

```{r}
library(igraph)

am.night.coord <- layout.fruchterman.reingold(ig.night.mb)
am.day.coord <- layout.fruchterman.reingold(ig.day.mb)

edges_g1 <- unique(apply(as_edgelist(ig.day.mb), 1, function(x) paste(sort(x), collapse = "-")))
edges_g2 <- unique(apply(as_edgelist(ig.night.mb), 1, function(x) paste(sort(x), collapse = "-")))
unique_edges <- length(unique(c(edges_g1, edges_g2)))
shared_edges <- intersect(edges_g1, edges_g2)

length(edges_g1) # Number of edges in day network
length(edges_g2) # Number of edges in night network
# Number of shared edges
length(shared_edges)

plot(ig.night.mb, layout=am.night.coord, vertex.size=vsize.night, main="MB - night")
plot(ig.day.mb, layout=am.day.coord, vertex.size=vsize.day, main="MB - day")
```

Computing centrality measures for day and night networks:

Defining a function to compute centrality measures:

```{r}
# From Lahti et al. 2021. Orchestrating Microbiome Analysis with Bioconductor (https://microbiome.github.io/OMA/docs/devel/pages/60_network_learning.html)
get_centr <- function(graph_obj) {
  df <- data.frame(Degree = igraph::degree(graph_obj))
  df$Betweenness <- betweenness(graph_obj)
  df$Closeness <- closeness(graph_obj, normalized = TRUE)
  df$Eigenvector <- eigen_centrality(graph_obj)$vector
  return(df)
}
```


```{r}
centr_day_df <- get_centr(ig.day.mb)
centr_night_df <- get_centr(ig.night.mb)

# Plotting with node size proportional to degree centrality
day_lay_fr <- layout_with_fr(ig.day.mb)
plot(ig.day.mb, layout = day_lay_fr, vertex.size = centr_day_df$Degree, main = "Day - Degree centrality", vertex.label.cex = 0.3)
night_lay_fr <- layout_with_fr(ig.night.mb)
plot(ig.night.mb, layout = night_lay_fr, vertex.size = centr_night_df$Degree, main = "Night - Degree centrality", vertex.label.cex = 0.3)
```

Plotting the degree distributions for day and night networks:

```{r}
ddist_day <- igraph::degree.distribution(ig.day.mb)
ddist_night <- igraph::degree.distribution(ig.night.mb)

day_ggplot_df <- data.frame(Degree = as.factor((seq_along(ddist_day)) - 1),
                 Fraction = ddist_day)
night_ggplot_df <- data.frame(Degree = as.factor((seq_along(ddist_night)) - 1),
                 Fraction = ddist_night)

library(gridExtra)
night_plot <- ggplot(data = night_ggplot_df, aes(x = Degree, y = Fraction, group = 1)) +
     geom_line() +
     geom_point() +
     theme_bw()
day_plot <- ggplot(data = day_ggplot_df, aes(x = Degree, y = Fraction, group = 1)) +
     geom_line() +
     geom_point() +
     theme_bw()
grid.arrange(day_plot, night_plot, ncol = 2)
```

Comparing networks with NetCoMi. Currently, only comparing the main statistics, the main centrality metrics (normalized).
For detecting hubs, we will use the degree centrality metric just to compare the list between these two networks.

```{r}
# 
adjma_se_mb_day <- as.matrix(symBeta(getOptBeta(se.mb.day_filtered_wallace2018)))
adjma_se_mb_night <- as.matrix(symBeta(getOptBeta(se.mb.night_filtered_wallace2018)))

colnames(adjma_se_mb_day) <- colnames(otu_day_filtered_wallace2018_transposed)
rownames(adjma_se_mb_day) <- colnames(otu_day_filtered_wallace2018_transposed)
colnames(adjma_se_mb_night) <- colnames(otu_night_filtered_wallace2018_transposed)
rownames(adjma_se_mb_night) <- colnames(otu_night_filtered_wallace2018_transposed)

se_mb_day_night_net <- netConstruct(data = adjma_se_mb_day,
                               data2 = adjma_se_mb_night,
                               dataType = "condDependence", normMethod = "none", 
                               sparsMethod = "none", zeroMethod = "none", 
                               verbose = 3, seed = 1234)

se_mb_day_night_netprops <- netAnalyze(se_mb_day_night_net, avDissIgnoreInf = TRUE,
                                    clustMethod = "cluster_fast_greedy",
                                    hubPar = c("degree"), hubQuant = 0.95,
                                    normDeg = TRUE, centrLCC = FALSE, normBetw = TRUE,
                                    normEigen = TRUE)

summary(se_mb_day_night_netprops, groupNames = c("Day period", "Night period"))

plot(se_mb_day_night_netprops, 
      sameLayout = TRUE, 
      layoutGroup = 1,
      rmSingles = "inboth", 
      nodeSize = "degree", 
      nodeColor = "cluster",
      labelScale = FALSE,
      cexNodes = 0.5, 
      cexLabels = 0.1,
      cexHubLabels = 0.2,
      cexTitle = 1.0,
      groupNames = c("Day period", "Night period"),
      hubBorderCol  = "gray40")
```













## SpiecEasi with MB model (merged datasets)

Using SpiecEasi, which uses a graphical model to analyze directly correlated nodes (SparCC does not account for populations indirectly correlated).
[Birt and Dennis, 2021](https://doi.org/10.1007/978-1-0716-1040-4_14) provides a great starting point for the analysis of co-occurrence networks with Spiec-Easi, that I (RACS) will follow.

Running spiec.easi with the merged dataset:

```{r}
library(SpiecEasi)
merged_matrix_wallace2018 <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/summed_day_night_otu_counts_filtered_sparxcc_data.tsv', sep='\t', header=TRUE, row.names=1)
merged_matrix_wallace2018_transposed <- t(merged_matrix_wallace2018)
# Using Meinshausen-Bühlman (MB) method (node wise regression model)
se.mb.wallace2018_merged <- spiec.easi(merged_matrix_wallace2018_transposed, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
```

Visualizing the network with igraph:

```{r}
library(igraph)
ig.mb     <- adj2igraph(getRefit(se.mb.wallace2018_merged))
## set size of vertex proportional to clr-mean (from [spiec-easi tutorial](https://github.com/zdk123/SpiecEasi))
vsize    <- rowMeans(clr(merged_matrix_wallace2018_transposed, 1))+6
am.coord <- layout.fruchterman.reingold(ig.mb)
plot(ig.mb, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="MB")
```

Generating the network from the Spiec-Easi object (with MB model)

```{r}
# Extracting the adjacency matrix from spiec.easi object
se.mb.wallace2018_merged.matrix <- symBeta(getOptBeta(se.mb.wallace2018_merged), mode='maxabs')
se.mb.wallace2018_merged.matrix.dsc <-  se.mb.wallace2018_merged.matrix
se.mb.wallace2018_merged.matrix < as.matrix(se.mb.wallace2018_merged.matrix)

# Renaming rows and columns of the adjacency matrix
rownames(se.mb.wallace2018_merged.matrix) <- colnames(merged_matrix_wallace2018_transposed)
colnames(se.mb.wallace2018_merged.matrix) <- colnames(merged_matrix_wallace2018_transposed)
otu.names <- colnames(merged_matrix_wallace2018_transposed)

# Generating the graph from the adjacency matrix
library(igraph)
se.mb.wallace2018_merged.net <- graph_from_adjacency_matrix(se.mb.wallace2018_merged.matrix, mode = c("undirected"), weighted = TRUE, diag = FALSE)
V(se.mb.wallace2018_merged.net)$name <- otu.names
se.mb.wallace2018_merged.net.dist <- se.mb.wallace2018_merged.net
weights.dist <- 1 - abs(E(se.mb.wallace2018_merged.net.dist)$weight)
E(se.mb.wallace2018_merged.net.dist)$weight <- weights.dist
se.mb.wallace2018_merged.net.abs <- se.mb.wallace2018_merged.net
E(se.mb.wallace2018_merged.net.abs)$weight <- abs(E(se.mb.wallace2018_merged.net.abs)$weight)
```

Computing centrality metrics and create summary:

```{r}
# Calculating alpha centrality of vertices
net.alpha <- alpha_centrality(se.mb.wallace2018_merged.net)
# degree distribution
net.strength <- strength(se.mb.wallace2018_merged.net.abs)
# betweenness centrality
bet <- betweenness(se.mb.wallace2018_merged.net.dist, v = V(se.mb.wallace2018_merged.net.dist))


summary_cent <- as.data.frame(net.alpha)
colnames(summary_cent) <- ("Alpha_centrality")
rownames(summary_cent) <- colnames(merged_matrix_wallace2018_transposed)
summary_cent$Weighted_vertex_degree <- net.strength
summary_cent$Betweenness_centrality <- bet
metrics <- summary_cent
```

Clustering the network:

```{r}
wt <- cluster_louvain(se.mb.wallace2018_merged.net, weights = E(se.mb.wallace2018_merged.net.dist)$weight)
temp <- V(se.mb.wallace2018_merged.net)$name
temp <- as.data.frame(temp)
temp$louvain <- membership(wt)
V(se.mb.wallace2018_merged.net)$louvain <- temp$louvain
``

### SpiecEasi with samples of each group (day and night, maize subpopulations)

```{r}
merged_matrix_wallace2018 <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/summed_day_night_otu_counts_filtered_sparxcc_data.tsv', sep='\t', header=TRUE, row.names=1)
maize_subpopulations <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/plant_center_retreat_2024/flint_garcia_group_assignments_wallace2018.tsv', sep='\t', header=TRUE, row.names=2)

# Filter the merged matrix to keep only the columns present in the lists
# of different maize subpopulations
filtered_merged_matrix_mixed <- merged_matrix_wallace2018[, colnames(merged_matrix_wallace2018) %in% rownames(maize_subpopulations[maize_subpopulations$Subpopulation == 'mixed', ])]
filtered_merged_matrix_ss <- merged_matrix_wallace2018[, colnames(merged_matrix_wallace2018) %in% rownames(maize_subpopulations[maize_subpopulations$Subpopulation == 'ss', ])]
filtered_merged_matrix_nss <- merged_matrix_wallace2018[, colnames(merged_matrix_wallace2018) %in% rownames(maize_subpopulations[maize_subpopulations$Subpopulation == 'nss', ])]
filtered_merged_matrix_ts <- merged_matrix_wallace2018[, colnames(merged_matrix_wallace2018) %in% rownames(maize_subpopulations[maize_subpopulations$Subpopulation == 'ts', ])]

# Transposing the merged_matrix_wallace2018_transposed
filtered_merged_matrix_mixed_transpose <- t(filtered_merged_matrix_mixed)
filtered_merged_matrix_ts_transpose <- t(filtered_merged_matrix_ts)
filtered_merged_matrix_ss_transpose <- t(filtered_merged_matrix_ss)
filtered_merged_matrix_nss_transpose <- t(filtered_merged_matrix_nss)

# Running spiec-easi
se.mb.wallace2018_merged_mixed <- spiec.easi(filtered_merged_matrix_mixed_transpose, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
se.mb.wallace2018_merged_ss <- spiec.easi(filtered_merged_matrix_ss_transpose, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
se.mb.wallace2018_merged_nss <- spiec.easi(filtered_merged_matrix_nss_transpose, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
se.mb.wallace2018_merged_ts <- spiec.easi(filtered_merged_matrix_ts_transpose, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
```

## SpiecEasi with glasso (merged datasets)

Previous analyses were carried out with the MB model. Following [Layeghifard et al (2018)](https://doi.org/10.1007/978-1-4939-8728-3_16), here I use the glasso alternative.

```{r}
se.gl.wallace2018_merged <- spiec.easi(merged_matrix_wallace2018_transposed, method='glasso', lambda.min.ratio=1e-2, nlambda=20, icov.select.params=list(rep.num=50, ncores=4))
secor <- cov2cor(getOptCov(se.gl.wallace2018_merged))
elist.gl <- summary(triu(secor*getRefit(se.gl.wallace2018_merged), k=1))
#se.gl.wallace2018_merged.net <- graph.adjacency(, mode="undirected", diag=FALSE)
```

Visualizing the network with igraph:

```{r}
library(igraph)
ig.gl     <- adj2igraph(getRefit(se.gl.wallace2018_merged))
## set size of vertex proportional to clr-mean (from [spiec-easi tutorial](https://github.com/zdk123/SpiecEasi))
vsize    <- rowMeans(clr(merged_matrix_wallace2018_transposed, 1))+6
am.coord <- layout.fruchterman.reingold(ig.gl)
plot(ig.gl, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="glasso")
```

## Running the optimized SparCC implementation in Spiec-Easi (merged datasets)

```{r}
sparcc.wallace2018_merged.matrix <- sparcc(merged_matrix_wallace2018_transposed)
sparcc.cutoff <- 0.3
sparcc.adj <- ifelse(abs(sparcc.wallace2018_merged.matrix$Cor) >= sparcc.cutoff, 1, 0)
rownames(sparcc.adj) <- colnames(merged_matrix_wallace2018_transposed)
colnames(sparcc.adj) <- colnames(merged_matrix_wallace2018_transposed)
sparcc.net <- graph.adjacency(sparcc.adj, mode="undirected", diag=FALSE)
```

Visualizing the network with igraph:

```{r}
library(igraph)
ig.sparcc     <- adj2igraph(sparcc.adj)
## set size of vertex proportional to clr-mean (from [spiec-easi tutorial](https://github.com/zdk123/SpiecEasi))
vsize    <- rowMeans(clr(merged_matrix_wallace2018_transposed, 1))+6
am.coord <- layout.fruchterman.reingold(ig.sparcc)
plot(ig.sparcc, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="SparCC")
```


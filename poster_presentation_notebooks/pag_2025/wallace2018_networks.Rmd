# Network generation for Wallace et al. 2018

I (RACS) will use different datasets for the OTU counts:

 * Merged day and night (used in cross-correlation analyses, selecting samples with RNA-Seq pairs)
 * The original dataset with all samples (day and night samples considered separately)

To reduce the number of OTUs used in the analyses, I (RACS) will use the same OTUs used in the SparXCC analyses (cross-correlations between genes and OTUs) for some analyses:

 * `summed_day_night_otu_counts_filtered_sparxcc_data.tsv` is the table with OTU counts, but after selecting only the OTUs used in the SparXCC analyses.
 * `original_otu_counts_filtered_sparxcc_data.tsv` is the original OTU table counts (with all samples, not only the paired), after selecting only the OTUs used in the SparXCC analyses.

`summed_day_night_otu_counts_filtered_sparxcc_data.tsv` is different from the matrix used in SparXCC, because that way preserved the 'day' and 'night' labels in matrix columns just for the purpose of matching names in the RNA-seq (but they had the same values).
Since we are now interested ONLY in the relations among the OTU nodes (co-occurrence networks), we will keep the names referring only to plot and day (e.g., 14A0199_8).

Additionally, I (RACS) will also use the original OTU table counts (with all samples, not only the paired), to compare networks between day and night samples:
 * `original_otu_filtered_day.tsv`
 * `original_otu_filtered_night.tsv`

These datasets were obtained as described in `co_occurrence_matrix_day_periods.ipynb` (PAG 25 folder).

Using SpiecEasi, which uses a graphical model to analyze directly correlated nodes (SparCC does not account for populations indirectly correlated).
[Birt and Dennis, 2021](https://doi.org/10.1007/978-1-0716-1040-4_14) provides a great starting point for the analysis of co-occurrence networks with Spiec-Easi, that I (RACS) will follow.

## Testing if networks for day and night samples are similar

To test if if networks for day and night samples are similar, I (RACS) used SpiecEasi with MB model to reconstruct separate networks for the day and the night matrices from the original OTU table after filtering by relative abundance (keeping OTUs with 0.001 relative abundance for at least half samples, approx. 270 samples). Filtering steps are described in `co_occurrence_matrix_day_periods.ipynb`.

Running spiec.easi with the day and night datasets:

```{r}
library(SpiecEasi)

otu_day_filtered_wallace2018 <- read.csv('/home/santosrac/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/original_otu_filtered_day.tsv', sep='\t', header=TRUE, row.names=1)
#read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/original_otu_filtered_day.tsv', sep='\t', header=TRUE, row.names=1)
otu_night_filtered_wallace2018 <- read.csv('/home/santosrac/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/original_otu_filtered_night.tsv', sep='\t', header=TRUE, row.names=1)
#read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/original_otu_filtered_night.tsv', sep='\t', header=TRUE, row.names=1)
head(otu_day_filtered_wallace2018)
head(otu_night_filtered_wallace2018)
# Transposing the matrices
otu_day_filtered_wallace2018_transposed <- t(otu_day_filtered_wallace2018)
otu_night_filtered_wallace2018_transposed <- t(otu_night_filtered_wallace2018)
# Using Meinshausen-Bühlman (MB) method (node wise regression model)
se.mb.day_filtered_wallace2018 <- spiec.easi(otu_day_filtered_wallace2018_transposed, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=1))
se.mb.night_filtered_wallace2018 <- spiec.easi(otu_night_filtered_wallace2018_transposed, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=1))
```

Visualizing the network with igraph:

```{r}
# Adding OTU names to the adjacency matrix
se.mb.night_filtered_wallace2018_matrix <- getRefit(se.mb.night_filtered_wallace2018)
se.mb.day_filtered_wallace2018_matrix <- getRefit(se.mb.day_filtered_wallace2018)
rownames(se.mb.day_filtered_wallace2018_matrix) <- colnames(otu_day_filtered_wallace2018_transposed)
rownames(se.mb.night_filtered_wallace2018_matrix) <- colnames(otu_night_filtered_wallace2018_transposed)

ig.day.mb <- adj2igraph(se.mb.day_filtered_wallace2018_matrix, vertex.attr=list(name=rownames(se.mb.day_filtered_wallace2018_matrix)))
ig.night.mb <- adj2igraph(se.mb.night_filtered_wallace2018_matrix, vertex.attr=list(name=rownames(se.mb.night_filtered_wallace2018_matrix)))

## set size of vertex proportional to clr-mean (from [spiec-easi tutorial](https://github.com/zdk123/SpiecEasi))
vsize.night    <- rowMeans(clr(otu_night_filtered_wallace2018_transposed, 1))+6
vsize.day    <- rowMeans(clr(otu_day_filtered_wallace2018_transposed, 1))+6

```

Using Fruchterman-Reingold layout (a force-directed layout) for node placement.
Strongly connected nodes are close together; nodes with low edge weight are far apart.
See [Lahti et al. 2021. Orchestrating Microbiome Analysis with Bioconductor](https://microbiome.github.io/OMA/docs/devel/pages/60_network_learning.html)
See also [this link from sciencedirect](https://www.sciencedirect.com/topics/computer-science/reingold-layout)

```{r}
library(igraph)

am.night.coord <- layout.fruchterman.reingold(ig.night.mb)
am.day.coord <- layout.fruchterman.reingold(ig.day.mb)

edges_g1 <- unique(apply(as_edgelist(ig.day.mb), 1, function(x) paste(sort(x), collapse = "-")))
edges_g2 <- unique(apply(as_edgelist(ig.night.mb), 1, function(x) paste(sort(x), collapse = "-")))
unique_edges <- length(unique(c(edges_g1, edges_g2)))
shared_edges <- intersect(edges_g1, edges_g2)
# E(ig.day.mb %s% ig.night.mb) is an alternative way of finding the shared edges
shared_edges

length(edges_g1) # Number of edges in day network
length(edges_g2) # Number of edges in night network
# Number of shared edges
length(shared_edges)

# Generating graphs with edges that are exclusive to only day or night
ig.day.mb.diff.night <- difference(ig.day.mb, ig.night.mb)
ig.night.mb.diff.day <- difference(ig.night.mb, ig.day.mb)
edges_only_day <- unique(apply(as_edgelist(ig.day.mb.diff.night), 1, function(x) paste(sort(x), collapse = "-")))
edges_only_night <- unique(apply(as_edgelist(ig.night.mb.diff.day), 1, function(x) paste(sort(x), collapse = "-")))

write.csv(edges_only_day, "edges_only_day.csv", row.names=F, quote=F)
write.csv(edges_only_night, "edges_only_night.csv", row.names=F, quote=F)
write.csv(shared_edges, "shared_edges.csv", row.names=F, quote=F)

am.day_only_edges.coord <- layout.fruchterman.reingold(ig.day.mb.diff.night)
am.night_only_edges.coord <- layout.fruchterman.reingold(ig.night.mb.diff.day)

plot(ig.night.mb, layout=am.night.coord, vertex.size=vsize.night, main="MB - night")
plot(ig.day.mb, layout=am.day.coord, vertex.size=vsize.day, main="MB - day")
plot(ig.day.mb.diff.night, layout=am.day_only_edges.coord, vertex.size=vsize.day, main="MB - only day edges")
plot(ig.night.mb.diff.day, layout=am.night_only_edges.coord, vertex.size=vsize.night, main="MB - only night edges")
```


## Analyzing one single network with merged read counts (day and night)

Using the dataframe with merged day and night samples, I generated two dataframes:

 * `merged_using_otus_from_cross_cross_correlation_with_merged_otus_df.txt`: columns are individual days of merged day and night samples. Rows are OTUs that were generated in the cross-correlation analysis presented in the plant center retreat - approximately 550 OTUs filtered based on the relative abundance and coef of variation, from the matrix with microbiome data with a paired RNA-seq.  
 * `merged_using_otus_from_co_occurrence_with_original_otus_df.txt`: columns are individual days of merged day and night samples. Rows are OTUs filtered based on relative abundance, from the original matrix with microbiome data, regardless of having paired RNA-Seq.

Generation of these matrices are described in `co_occurrence_matrix_day_periods_merged.ipynb` (pag25 folder).

Firstly, I (RACS) wanted to compare the centrality metrics and number of edges in the network of merged reads with the night and day separately (previously compared in this notebook).

```{r}
# Importing the matrix
otu_merged_filtered_wallace2018 <- read.csv('/home/santosrac/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/merged_using_otus_from_co_occurrence_with_original_otus_df.txt', sep='\t', header=TRUE, row.names=1)
head(otu_merged_filtered_wallace2018)
dim(otu_merged_filtered_wallace2018)
# Transposing the matrix
otu_merged_filtered_wallace2018_transposed <- t(otu_merged_filtered_wallace2018)
# Using Meinshausen-Bühlman (MB) method (node wise regression model)
se.mb.merged_filtered_wallace2018 <- spiec.easi(otu_merged_filtered_wallace2018_transposed, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=1))

# Adding OTU names to the adjacency matrix
se.mb.merged_filtered_wallace2018_matrix <- getRefit(se.mb.merged_filtered_wallace2018)
rownames(se.mb.merged_filtered_wallace2018_matrix) <- colnames(otu_merged_filtered_wallace2018_transposed)

ig.merged.mb <- adj2igraph(se.mb.merged_filtered_wallace2018_matrix, vertex.attr=list(name=rownames(se.mb.merged_filtered_wallace2018_matrix)))

## set size of vertex proportional to clr-mean (from [spiec-easi tutorial](https://github.com/zdk123/SpiecEasi))
vsize.merged    <- rowMeans(clr(otu_merged_filtered_wallace2018_transposed, 1))+6

am.merged.coord <- layout.fruchterman.reingold(ig.merged.mb)

edges_merged <- unique(apply(as_edgelist(ig.merged.mb), 1, function(x) paste(sort(x), collapse = "-")))
length(edges_merged) # Number of edges in merged network

# Number of edges shared between different networks
length(E(ig.day.mb %s% ig.night.mb)) # Day and night networks
length(E(ig.day.mb %s% ig.merged.mb)) # Day and merged networks
length(E(ig.night.mb %s% ig.merged.mb)) # Night and merged networks
```

## Computing centrality measures for day, night, and merged networks:

Defining a function to compute centrality measures:

```{r}
# From Lahti et al. 2021. Orchestrating Microbiome Analysis with Bioconductor (https://microbiome.github.io/OMA/docs/devel/pages/60_network_learning.html)
get_centr <- function(graph_obj) {
  df <- data.frame(Degree = igraph::degree(graph_obj))
  df$Betweenness <- betweenness(graph_obj)
  df$Closeness <- closeness(graph_obj, normalized = TRUE)
  df$Eigenvector <- eigen_centrality(graph_obj)$vector
  return(df)
}
```


```{r}
centr_day_df <- get_centr(ig.day.mb)
centr_night_df <- get_centr(ig.night.mb)

# Plotting with node size proportional to degree centrality
day_lay_fr <- layout_with_fr(ig.day.mb)
plot(ig.day.mb, layout = day_lay_fr, vertex.size = centr_day_df$Degree, main = "Day - Degree centrality", vertex.label.cex = 0.3)
night_lay_fr <- layout_with_fr(ig.night.mb)
plot(ig.night.mb, layout = night_lay_fr, vertex.size = centr_night_df$Degree, main = "Night - Degree centrality", vertex.label.cex = 0.3)
```

Plotting the degree distributions for day and night networks:

```{r}
ddist_day <- igraph::degree.distribution(ig.day.mb)
ddist_night <- igraph::degree.distribution(ig.night.mb)

day_ggplot_df <- data.frame(Degree = as.factor((seq_along(ddist_day)) - 1),
                 Fraction = ddist_day)
night_ggplot_df <- data.frame(Degree = as.factor((seq_along(ddist_night)) - 1),
                 Fraction = ddist_night)

library(gridExtra)
night_plot <- ggplot(data = night_ggplot_df, aes(x = Degree, y = Fraction, group = 1)) +
     geom_line() +
     geom_point() +
     theme_bw()
day_plot <- ggplot(data = day_ggplot_df, aes(x = Degree, y = Fraction, group = 1)) +
     geom_line() +
     geom_point() +
     theme_bw()
grid.arrange(day_plot, night_plot, ncol = 2)
```

Comparing networks with NetCoMi. Currently, only comparing the main statistics, the main centrality metrics (normalized).
For detecting hubs, we will use the degree centrality metric just to compare the list between these two networks.

```{r}
# 
adjma_se_mb_day <- as.matrix(symBeta(getOptBeta(se.mb.day_filtered_wallace2018)))
adjma_se_mb_night <- as.matrix(symBeta(getOptBeta(se.mb.night_filtered_wallace2018)))

colnames(adjma_se_mb_day) <- colnames(otu_day_filtered_wallace2018_transposed)
rownames(adjma_se_mb_day) <- colnames(otu_day_filtered_wallace2018_transposed)
colnames(adjma_se_mb_night) <- colnames(otu_night_filtered_wallace2018_transposed)
rownames(adjma_se_mb_night) <- colnames(otu_night_filtered_wallace2018_transposed)

se_mb_day_night_net <- netConstruct(data = adjma_se_mb_day,
                               data2 = adjma_se_mb_night,
                               dataType = "condDependence", normMethod = "none", 
                               sparsMethod = "none", zeroMethod = "none", 
                               verbose = 3, seed = 1234)

se_mb_day_night_netprops <- netAnalyze(se_mb_day_night_net, avDissIgnoreInf = TRUE,
                                    clustMethod = "cluster_fast_greedy",
                                    hubPar = c("degree"), hubQuant = 0.95,
                                    normDeg = TRUE, centrLCC = FALSE, normBetw = TRUE,
                                    normEigen = TRUE)

summary(se_mb_day_night_netprops, groupNames = c("Day period", "Night period"))

plot(se_mb_day_night_netprops, 
      sameLayout = TRUE, 
      layoutGroup = 1,
      rmSingles = "inboth", 
      nodeSize = "degree", 
      nodeColor = "cluster",
      labelScale = FALSE,
      cexNodes = 0.5, 
      cexLabels = 0.1,
      cexHubLabels = 0.2,
      cexTitle = 1.0,
      groupNames = c("Day period", "Night period"),
      hubBorderCol  = "gray40")
```



```{r}
# Extracting the adjacency matrix from spiec.easi object
se.mb.day_filtered_wallace2018.matrix <- symBeta(getOptBeta(se.mb.day_filtered_wallace2018), mode='maxabs')
se.mb.day_filtered_wallace2018.matrix.dsc <-  se.mb.day_filtered_wallace2018.matrix
se.mb.day_filtered_wallace2018.matrix < as.matrix(se.mb.day_filtered_wallace2018.matrix)

se.mb.night_filtered_wallace2018.matrix <- symBeta(getOptBeta(se.mb.night_filtered_wallace2018), mode='maxabs')
se.mb.night_filtered_wallace2018.matrix.dsc <-  se.mb.night_filtered_wallace2018.matrix
se.mb.night_filtered_wallace2018.matrix < as.matrix(se.mb.night_filtered_wallace2018.matrix)

# Renaming rows and columns of the adjacency matrix
rownames(se.mb.day_filtered_wallace2018.matrix) <- colnames(otu_day_filtered_wallace2018_transposed)
colnames(se.mb.day_filtered_wallace2018.matrix) <- colnames(otu_day_filtered_wallace2018_transposed)
day.otu.names <- colnames(otu_day_filtered_wallace2018_transposed)

rownames(se.mb.night_filtered_wallace2018.matrix) <- colnames(otu_night_filtered_wallace2018_transposed)
colnames(se.mb.night_filtered_wallace2018.matrix) <- colnames(otu_night_filtered_wallace2018_transposed)
night.otu.names <- colnames(otu_night_filtered_wallace2018_transposed)

# Generating the graph from the adjacency matrix
se.mb.day_filtered_wallace2018.matrix_net <- graph_from_adjacency_matrix(se.mb.day_filtered_wallace2018.matrix, mode = c("undirected"), weighted = TRUE, diag = FALSE)
V(se.mb.day_filtered_wallace2018.matrix_net)$name <- day.otu.names
se.mb.day_filtered_wallace2018.matrix_net.dist <- se.mb.day_filtered_wallace2018.matrix_net
max(abs(E(se.mb.day_filtered_wallace2018.matrix_net.dist)$weight))
day.weights.dist <- 1 - abs(E(se.mb.day_filtered_wallace2018.matrix_net.dist)$weight)
E(se.mb.day_filtered_wallace2018.matrix_net.dist)$weight <- day.weights.dist
se.mb.day_filtered_wallace2018.matrix_net.abs <- se.mb.day_filtered_wallace2018.matrix_net
E(se.mb.day_filtered_wallace2018.matrix_net.abs)$weight <- abs(E(se.mb.day_filtered_wallace2018.matrix_net.abs)$weight)

se.mb.night_filtered_wallace2018.matrix_net <- graph_from_adjacency_matrix(se.mb.night_filtered_wallace2018.matrix, mode = c("undirected"), weighted = TRUE, diag = FALSE)
V(se.mb.night_filtered_wallace2018.matrix_net)$name <- night.otu.names
se.mb.night_filtered_wallace2018.matrix_net.dist <- se.mb.night_filtered_wallace2018.matrix_net
max(abs(E(se.mb.night_filtered_wallace2018.matrix_net.dist)$weight))
night.weights.dist <- 1 - abs(E(se.mb.night_filtered_wallace2018.matrix_net.dist)$weight)
E(se.mb.night_filtered_wallace2018.matrix_net.dist)$weight <- night.weights.dist
se.mb.night_filtered_wallace2018.matrix_net.abs <- se.mb.night_filtered_wallace2018.matrix_net
E(se.mb.night_filtered_wallace2018.matrix_net.abs)$weight <- abs(E(se.mb.night_filtered_wallace2018.matrix_net.abs)$weight)
```

Computing centrality metrics:

```{r}
# Calculating alpha centrality of vertices
day.net.alpha <- alpha_centrality(se.mb.day_filtered_wallace2018.matrix_net)
night.net.alpha <- alpha_centrality(se.mb.night_filtered_wallace2018.matrix_net)
# degree distribution
day.net.strength <- strength(se.mb.day_filtered_wallace2018.matrix_net.abs)
night.net.strength <- strength(se.mb.night_filtered_wallace2018.matrix_net.abs)
# betweenness centrality
day.bet <- betweenness(se.mb.day_filtered_wallace2018.matrix_net.dist, v = V(se.mb.day_filtered_wallace2018.matrix_net.dist))
night.bet <- betweenness(se.mb.night_filtered_wallace2018.matrix_net.dist, v = V(se.mb.night_filtered_wallace2018.matrix_net.dist))
```

Creating summaries:

```{r}
day.summary_cent <- as.data.frame(day.net.alpha)
colnames(day.summary_cent) <- ("Alpha_centrality")
rownames(day.summary_cent) <- colnames(otu_day_filtered_wallace2018_transposed)
day.summary_cent$Weighted_vertex_degree <- day.net.strength
day.summary_cent$Betweenness_centrality <- day.bet
day.metrics <- day.summary_cent
day.metrics
```

```{r}
night.summary_cent <- as.data.frame(night.net.alpha)
colnames(night.summary_cent) <- ("Alpha_centrality")
rownames(night.summary_cent) <- colnames(otu_night_filtered_wallace2018_transposed)
night.summary_cent$Weighted_vertex_degree <- night.net.strength
night.summary_cent$Betweenness_centrality <- night.bet
night.metrics <- night.summary_cent
night.metrics
```

Clustering the network:

```{r}
day_wt <- cluster_louvain(se.mb.day_filtered_wallace2018.matrix_net, weights = E(se.mb.day_filtered_wallace2018.matrix_net.dist)$weight)
day_temp <- V(se.mb.day_filtered_wallace2018.matrix_net)$name
day_temp <- as.data.frame(day_temp)
day_temp$louvain <- membership(day_wt)

night_wt <- cluster_louvain(se.mb.night_filtered_wallace2018.matrix_net, weights = E(se.mb.night_filtered_wallace2018.matrix_net.dist)$weight)
night_temp <- V(se.mb.night_filtered_wallace2018.matrix_net)$name
night_temp <- as.data.frame(night_temp)
night_temp$louvain <- membership(night_wt)

V(se.mb.day_filtered_wallace2018.matrix_net)$louvain <- day_temp$louvain
V(se.mb.night_filtered_wallace2018.matrix_net)$louvain <- night_temp$louvain
```

## Analyzing the network for the main text

After comparing different networks to make sure I (RACS) can merge day and night samples, I reconstructed a network with the same OTUs used in the cross-correlation analyses. This network will be used to analyze the microbial communities for the main text. Other analyses in this notebook go to sup mat.

```{r}

```



# Network generation for Wallace et al. 2018

I (RACS) will use two datasets for the OTU counts:

 * Merged day and night (used in cross-correlation analyses)
 * The original dataset with all samples (day and night samples considered separately)

To reduce the number of OTUs used in the analyses, I (RACS) will use the same OTUs used in the SparXCC analyses (cross-correlations between genes and OTUs).

##

 * `summed_day_night_otu_counts_filtered_sparxcc_data.tsv` is the table with OTU counts, but after selecting only the OTUs used in the SparXCC analyses.
 * `original_otu_counts_filtered_sparxcc_data.tsv` is the original OTU table counts (with all samples, not only the paired), after selecting only the OTUs used in the SparXCC analyses.


`summed_day_night_otu_counts_filtered_sparxcc_data.tsv` is different from the matrix used in SparXCC, because that way preserved the 'day' and 'night' labels in matrix columns just for the purpose of matching names in the RNA-seq (but they had the same values).
Since we are now interested ONLY in the relations among the OTU nodes (co-occurrence networks), we will keep the names referring only to plot and day (e.g., 14A0199_8).

## First tests with SPRING in NetCoMi

Using NetCoMi to generate networks.


### Using Wallace et al (2018) - original and merged data

```{r}
library(NetCoMi)

merged_matrix_wallace2018 <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/16S_wallace2018/combine_day_night_samples/summed_day_night_otu_counts.tsv', sep='\t', header=TRUE, row.names=1)
merged_matrix_wallace2018_transposed <- t(merged_matrix_wallace2018)
	
net_spring_merged <- netConstruct(merged_matrix_wallace2018_transposed,
                           filtTax = "highestFreq",
                           filtTaxPar = list(highestFreq = 200),
                           filtSamp = "totalReads",
                           filtSampPar = list(totalReads = 10000),
                           measure = "spring",
                           measurePar = list(nlambda=100,
                                             rep.num=100,
                                             Rmethod = "approx"),
                           normMethod = "none", # Normalization as well as zero handling is performed internally in SPRING
                           zeroMethod = "none",
                           sparsMethod = "none",
                           dissFunc = "signed",
                           verbose = 3, # Shows all messages, including those from SPRING
                           seed = 123456)

original_matrix_wallace2018 <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/original_otu_counts_filtered_sparxcc_data.tsv',
    sep='\t', header=TRUE, row.names=1)
original_matrix_wallace2018_transposed <- t(original_matrix_wallace2018)
column_sums <- colSums(original_matrix_wallace2018_transposed)

sorted_column_sums <- sort(column_sums, decreasing = FALSE)

last_300_column_sums <- tail(sorted_column_sums, 300)
print(last_300_column_sums)

hist(last_300_column_sums, 
    main="Histogram of Column Sums", 
    xlab="Column Sums", 
    ylab="Frequency", 
    col="blue", 
    border="black")

row_sums <- rowSums(original_matrix_wallace2018_transposed)

sorted_row_sums <- sort(row_sums, decreasing = FALSE)

last_300_row_sums <- tail(sorted_row_sums, 300)
print(last_300_row_sums)

hist(last_300_row_sums, 
    main="Histogram of Row Sums", 
    xlab="Row Sums", 
    ylab="Frequency", 
    col="green", 
    border="black",
    breaks=100)

net_spring <- netConstruct(original_matrix_wallace2018_transposed,
                           filtTax = "highestFreq",
                           filtTaxPar = list(highestFreq = 255),
                           filtSamp = "totalReads",
                           filtSampPar = list(totalReads = 5000),
                           measure = "spring",
                           measurePar = list(nlambda=100,
                                             rep.num=100,
                                             Rmethod = "approx"),
                           normMethod = "none", # Normalization as well as zero handling is performed internally in SPRING
                           zeroMethod = "none",
                           sparsMethod = "none",
                           dissFunc = "signed",
                           verbose = 3, # Shows all messages, including those from SPRING
                           seed = 123456)
```

The first time trying to run SPRING method in NetCoMi, I (RACS) got the following warning:

```bash
Warning messages:
1: In Matrix::nearPD(R, corr = TRUE) :
  'nearPD()' did not converge in 100 iterations
2: 101 jobs had warning: "'nearPD()' did not converge in 100 iterations"
```

It is important to consider filtering out rare species by limiting the number of species based on frequency in the whole dataset or filtering samples by total reads count.
See the following issue for more information: [NetCoMi issue 22](https://github.com/stefpeschel/NetCoMi/issues/22)

Runs show above are final runs, after testing different values for OTU and sample depth/counts.

Exporting the edges and nodes to analyze the networks in softwares like Cytoscape and Gephi (adapted from NetCoMi guidelines):

```{r}
# Exporting edges and nodes for the original matrix
edges <- dplyr::select(net_spring$edgelist1, v1, v2)
edges$Source <- as.numeric(factor(edges$v1))
edges$Target <- as.numeric(factor(edges$v2))
edges$Type <- "Undirected"
edges$Weight <- net_spring$edgelist1$adja
nodes <- unique(edges[,c('v1','Source')])
colnames(nodes) <- c("Label", "Id")
nodes$Category <- props_spring$clustering$clust1[nodes$Label]
edges <- dplyr::select(edges, Source, Target, Type, Weight)
write.csv(nodes, file = "nodes.csv", row.names = FALSE)
write.csv(edges, file = "edges.csv", row.names = FALSE)

# Exporting edges and nodes for the merged matrix
edges_merged <- dplyr::select(net_spring_merged$edgelist1, v1, v2)
edges_merged$Source <- as.numeric(factor(edges_merged$v1))
edges_merged$Target <- as.numeric(factor(edges_merged$v2))
edges_merged$Type <- "Undirected"
edges_merged$Weight <- net_spring_merged$edgelist1$adja
nodes_merged <- unique(edges_merged[,c('v1','Source')])
colnames(nodes_merged) <- c("Label", "Id")
nodes_merged$Category <- props_spring$clustering$clust1[nodes_merged$Label]
edges_merged <- dplyr::select(edges_merged, Source, Target, Type, Weight)
write.csv(nodes_merged, file = "nodes_merged.csv", row.names = FALSE)
write.csv(edges_merged, file = "edges_merged.csv", row.names = FALSE)
```

## First tests with SparCC in NetCoMi

SparCC method is better than Pearson because it considers the compositional nature of metataxonomic data.

Spiec-Easi implemented a otimized version of SparCC, which is used in NetcoMi netContruct function.

```
net_sparcc <- netConstruct(,
                           filtTax = "highestFreq",
                           filtTaxPar = list(highestFreq = 50),
                           filtSamp = "totalReads",
                           filtSampPar = list(totalReads = 1000),
                           measure = "sparcc",
                           measurePar = NULL,
                           normMethod = "clr", # SparCC uses CLR data as input
                           zeroMethod = "none",
                           sparsMethod = "threshold", # in case of SparCC, an arbitrary value for sparsification was used like in Spiec-Easi example
                           thresh = 0.3,
                           dissFunc = "signed",
                           verbose = 2,
                           seed = 123456)
```

## SpiecEasi with MB model

Using SpiecEasi, which uses a graphical model to analyze directly correlated nodes (SparCC does not account for populations indirectly correlated).
[Birt and Dennis, 2021](https://doi.org/10.1007/978-1-0716-1040-4_14) provides a great starting point for the analysis of co-occurrence networks with Spiec-Easi, that I (RACS) will follow.

### SpiecEasi with all samples

Running spiec.easi with the merged dataset:

```{r}
library(SpiecEasi)
merged_matrix_wallace2018 <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/summed_day_night_otu_counts_filtered_sparxcc_data.tsv', sep='\t', header=TRUE, row.names=1)
merged_matrix_wallace2018_transposed <- t(merged_matrix_wallace2018)
# Using Meinshausen-BÃ¼hlman method (node wise regression model)
se.mb.wallace2018_merged <- spiec.easi(merged_matrix_wallace2018_transposed, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
```

Generating the network from the Spiec-Easi object (with MB model)

```{r}
# Extracting the adjacency matrix from spiec.easi object
se.mb.wallace2018_merged.matrix <- symBeta(getOptBeta(se.mb.wallace2018_merged), mode='maxabs')
se.mb.wallace2018_merged.matrix.dsc <-  se.mb.wallace2018_merged.matrix
se.mb.wallace2018_merged.matrix < as.matrix(se.mb.wallace2018_merged.matrix)

# Renaming rows and columns of the adjacency matrix
rownames(se.mb.wallace2018_merged.matrix) <- colnames(merged_matrix_wallace2018_transposed)
colnames(se.mb.wallace2018_merged.matrix) <- colnames(merged_matrix_wallace2018_transposed)
otu.names <- colnames(merged_matrix_wallace2018_transposed)

# Generating the graph from the adjacency matrix
library(igraph)
se.mb.wallace2018_merged.net <- graph_from_adjacency_matrix(se.mb.wallace2018_merged.matrix, mode = c("undirected"), weighted = TRUE, diag = FALSE)
V(se.mb.wallace2018_merged.net)$name <- otu.names
se.mb.wallace2018_merged.net.dist <- se.mb.wallace2018_merged.net
weights.dist <- 1 - abs(E(se.mb.wallace2018_merged.net.dist)$weight)
E(se.mb.wallace2018_merged.net.dist)$weight <- weights.dist
se.mb.wallace2018_merged.net.abs <- se.mb.wallace2018_merged.net
E(se.mb.wallace2018_merged.net.abs)$weight <- abs(E(se.mb.wallace2018_merged.net.abs)$weight)
```

Computing centrality metrics and create summary:

```{r}
# Calculating alpha centrality of vertices
net.alpha <- alpha_centrality(se.mb.wallace2018_merged.net)
# degree distribution
net.strength <- strength(se.mb.wallace2018_merged.net.abs)
# betweenness centrality
bet <- betweenness(se.mb.wallace2018_merged.net.dist, v = V(se.mb.wallace2018_merged.net.dist))


summary_cent <- as.data.frame(net.alpha)
colnames(summary_cent) <- ("Alpha_centrality")
rownames(summary_cent) <- colnames(merged_matrix_wallace2018_transposed)
summary_cent$Weighted_vertex_degree <- net.strength
summary_cent$Betweenness_centrality <- bet
metrics <- summary_cent
```

Clustering the network:

```{r}
wt <- cluster_louvain(se.mb.wallace2018_merged.net, weights = E(se.mb.wallace2018_merged.net.dist)$weight)
temp <- V(se.mb.wallace2018_merged.net)$name
temp <- as.data.frame(temp)
temp$louvain <- membership(wt)
V(se.mb.wallace2018_merged.net)$louvain <- temp$louvain
``

### SpiecEasi with samples of each group (day and night, maize subpopulations)

```{r}
merged_matrix_wallace2018 <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/pag_2025/summed_day_night_otu_counts_filtered_sparxcc_data.tsv', sep='\t', header=TRUE, row.names=1)
maize_subpopulations <- read.csv('/home/rsantos/Repositories/maize_microbiome_transcriptomics/poster_presentation_notebooks/plant_center_retreat_2024/flint_garcia_group_assignments_wallace2018.tsv', sep='\t', header=TRUE, row.names=2)

# Filter the merged matrix to keep only the columns present in the lists
# of different maize subpopulations
filtered_merged_matrix_mixed <- merged_matrix_wallace2018[, colnames(merged_matrix_wallace2018) %in% rownames(maize_subpopulations[maize_subpopulations$Subpopulation == 'mixed', ])]
filtered_merged_matrix_ss <- merged_matrix_wallace2018[, colnames(merged_matrix_wallace2018) %in% rownames(maize_subpopulations[maize_subpopulations$Subpopulation == 'ss', ])]
filtered_merged_matrix_nss <- merged_matrix_wallace2018[, colnames(merged_matrix_wallace2018) %in% rownames(maize_subpopulations[maize_subpopulations$Subpopulation == 'nss', ])]
filtered_merged_matrix_ts <- merged_matrix_wallace2018[, colnames(merged_matrix_wallace2018) %in% rownames(maize_subpopulations[maize_subpopulations$Subpopulation == 'ts', ])]

# Transposing the merged_matrix_wallace2018_transposed
filtered_merged_matrix_mixed_transpose <- t(filtered_merged_matrix_mixed)
filtered_merged_matrix_ts_transpose <- t(filtered_merged_matrix_ts)
filtered_merged_matrix_ss_transpose <- t(filtered_merged_matrix_ss)
filtered_merged_matrix_nss_transpose <- t(filtered_merged_matrix_nss)

# Running spiec-easi
se.mb.wallace2018_merged_mixed <- spiec.easi(filtered_merged_matrix_mixed_transpose, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
se.mb.wallace2018_merged_ss <- spiec.easi(filtered_merged_matrix_ss_transpose, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
se.mb.wallace2018_merged_nss <- spiec.easi(filtered_merged_matrix_nss_transpose, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
se.mb.wallace2018_merged_ts <- spiec.easi(filtered_merged_matrix_ts_transpose, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=50, ncores=4))
```

## SpiecEasi with glasso

Previous analyses were carried out with the MB model. Following [Layeghifard et al (2018)](https://doi.org/10.1007/978-1-4939-8728-3_16), here I use the glasso alternative.

```{r}
se.gl.wallace2018_merged <- spiec.easi(merged_matrix_wallace2018_transposed, method='glasso', lambda.min.ratio=1e-2, nlambda=20, icov.select.params=list(rep.num=50, ncores=4))

secor <- cov2cor(getOptCov(se.gl.wallace2018_merged))
elist.gl <- summary(triu(secor*getRefit(se.gl.wallace2018_merged), k=1))

#TODO: finish se gl and revise everything
#se.gl.wallace2018_merged.net <- graph.adjacency(, mode="undirected", diag=FALSE)
```

## Running the optimized SparCC implementation in Spiec-Easi

```{r}
sparcc.wallace2018_merged.matrix <- sparcc(merged_matrix_wallace2018_transposed)
sparcc.cutoff <- 0.3
sparcc.adj <- ifelse(abs(sparcc.wallace2018_merged.matrix$Cor) >= sparcc.cutoff, 1, 0)
rownames(sparcc.adj) <- colnames(merged_matrix_wallace2018_transposed)
colnames(sparcc.adj) <- colnames(merged_matrix_wallace2018_transposed)
sparcc.net <- graph.adjacency(sparcc.adj, mode="undirected", diag=FALSE)
```